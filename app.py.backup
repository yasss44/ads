# API Endpoints for Settings Sections
@app.route('/api/profile', methods=['GET'])
@login_required
def get_profile():
    """Get user profile information"""
    try:
        user = User.query.get(session['user_id'])
        if not user:
            return jsonify({'error': 'User not found'}), 404
        return jsonify(user.to_dict())
    except Exception as e:
        logger.error(f"Error fetching profile: {e}")
        return jsonify({'error': 'Failed to fetch profile'}), 500

@app.route('/api/notifications/settings', methods=['GET'])
@login_required
def get_notification_settings():
    """Get notification settings"""
    try:
        user = User.query.get(session['user_id'])
        # Mock settings to be replaced with actual database fetch
        settings = {
            'email_new_locations': True,
            'email_campaign_updates': True,
            'email_system_alerts': False
        }
        return jsonify(settings)
    except Exception as e:
        logger.error(f"Error fetching notification settings: {e}")
        return jsonify({'error': 'Failed to fetch notification settings'}), 500

@app.route('/api/security/settings', methods=['GET'])
@login_required
def get_security_settings():
    """Get security settings like 2FA & active sessions"""
    try:
        user = User.query.get(session['user_id'])
        # Mock security settings data
        settings = {
            'two_factor_auth': False,
            'active_sessions': 1
        }
        return jsonify(settings)
    except Exception as e:
        logger.error(f"Error fetching security settings: {e}")
        return jsonify({'error': 'Failed to fetch security settings'}), 500

@app.route('/api/preferences', methods=['GET'])
@login_required
def get_preferences():
    """Get user preferences"""
    try:
        user = User.query.get(session['user_id'])
        # Mock preferences
        preferences = {
            'language': 'en',
            'timezone': 'UTC',
            'date_format': 'MM/DD/YYYY',
            'dark_mode': True
        }
        return jsonify(preferences)
    except Exception as e:
        logger.error(f"Error fetching preferences: {e}")
        return jsonify({'error': 'Failed to fetch preferences'}), 500

from flask import Flask, request, jsonify, render_template, session, redirect, url_for, flash
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
import os
from datetime import datetime
from functools import wraps
import bcrypt
from datetime import datetime
from dotenv import load_dotenv
import logging

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)

# Configuration
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key')
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///dev.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Initialize extensions
db = SQLAlchemy(app)
CORS(app)

# User model for authentication
class User(db.Model):
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    role = db.Column(db.String(20), default='viewer')  # admin, client, viewer
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    is_active = db.Column(db.Boolean, default=True)
    
    def set_password(self, password):
        """Hash and set password"""
        self.password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    
    def check_password(self, password):
        """Check if provided password matches hash"""
        return bcrypt.checkpw(password.encode('utf-8'), self.password_hash.encode('utf-8'))
    
    def is_admin(self):
        """Check if user is admin"""
        return self.role == 'admin'
    
    def to_dict(self):
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'role': self.role,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'is_active': self.is_active
        }

# Enhanced models for enterprise features
class Location(db.Model):
    __tablename__ = 'locations'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    latitude = db.Column(db.Float)
    longitude = db.Column(db.Float)
    address = db.Column(db.String(255))
    status = db.Column(db.String(20), default='active')  # active, inactive, maintenance
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    creator = db.relationship('User', backref='created_locations')
    devices = db.relationship('Device', backref='location', cascade='all, delete-orphan')
    
    def to_dict(self):
        result = {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'address': self.address,
            'status': self.status,
            'created_by': self.creator.username if self.creator else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'device_count': len(self.devices)
        }
        
        # Include coordinates if available
        if self.latitude is not None and self.longitude is not None:
            result['latitude'] = self.latitude
            result['longitude'] = self.longitude
            
        return result

class Campaign(db.Model):
    __tablename__ = 'campaigns'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    status = db.Column(db.String(20), default='draft')  # draft, active, paused, completed
    budget = db.Column(db.Float, default=0.0)
    start_date = db.Column(db.DateTime)
    end_date = db.Column(db.DateTime)
    target_audience = db.Column(db.Text)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    client_id = db.Column(db.Integer, db.ForeignKey('users.id'))  # assigned client
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    creator = db.relationship('User', foreign_keys=[created_by], backref='created_campaigns')
    client = db.relationship('User', foreign_keys=[client_id], backref='assigned_campaigns')
    
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'status': self.status,
            'budget': self.budget,
            'start_date': self.start_date.isoformat() if self.start_date else None,
            'end_date': self.end_date.isoformat() if self.end_date else None,
            'target_audience': self.target_audience,
            'created_by': self.creator.username if self.creator else None,
            'client': self.client.username if self.client else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }

class Device(db.Model):
    __tablename__ = 'devices'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    device_type = db.Column(db.String(50), nullable=False)  # display, sensor, kiosk, etc.
    serial_number = db.Column(db.String(100), unique=True)
    status = db.Column(db.String(20), default='offline')  # online, offline, maintenance, error
    last_seen = db.Column(db.DateTime)
    location_id = db.Column(db.Integer, db.ForeignKey('locations.id'))
    firmware_version = db.Column(db.String(20))
    ip_address = db.Column(db.String(45))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'device_type': self.device_type,
            'serial_number': self.serial_number,
            'status': self.status,
            'last_seen': self.last_seen.isoformat() if self.last_seen else None,
            'location_id': self.location_id,
            'location_name': self.location.name if self.location else None,
            'firmware_version': self.firmware_version,
            'ip_address': self.ip_address,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }

class ActivityLog(db.Model):
    __tablename__ = 'activity_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    action = db.Column(db.String(100), nullable=False)
    details = db.Column(db.Text)
    ip_address = db.Column(db.String(45))
    user_agent = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships
    user = db.relationship('User', backref='activity_logs')
    
    def to_dict(self):
        return {
            'id': self.id,
            'user': self.user.username if self.user else None,
            'action': self.action,
            'details': self.details,
            'ip_address': self.ip_address,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }

# Helper functions
def log_activity(action, details=None):
    """Log user activity"""
    if 'user_id' in session:
        activity = ActivityLog(
            user_id=session['user_id'],
            action=action,
            details=details,
            ip_address=request.remote_addr,
            user_agent=request.headers.get('User-Agent')
        )
        db.session.add(activity)
        try:
            db.session.commit()
        except Exception as e:
            logger.error(f"Failed to log activity: {e}")
            db.session.rollback()

# Authentication decorators
def login_required(f):
    """Decorator to require login for routes"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            flash('You need to log in to access this page.', 'error')
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

def admin_required(f):
    """Decorator to require admin role for routes"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            flash('You need to log in to access this page.', 'error')
            return redirect(url_for('login'))
        
        user = User.query.get(session['user_id'])
        if not user or not user.is_admin():
            flash('You need admin privileges to access this page.', 'error')
            return redirect(url_for('dashboard'))
        
        return f(*args, **kwargs)
    return decorated_function

# Authentication Routes
@app.route('/login', methods=['GET', 'POST'])
def login():
    """User login"""
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if not username or not password:
            flash('Username and password are required.', 'error')
            return render_template('login.html')
        
        user = User.query.filter_by(username=username).first()
        
        if user and user.check_password(password) and user.is_active:
            session['user_id'] = user.id
            session['username'] = user.username
            session['role'] = user.role
            
            flash(f'Welcome back, {user.username}!', 'success')
            logger.info(f"User {user.username} logged in successfully")
            log_activity('user_login', f'User logged in from {request.remote_addr}')
            
            next_page = request.args.get('next')
            return redirect(next_page) if next_page else redirect(url_for('dashboard'))
        else:
            flash('Invalid username or password.', 'error')
            logger.warning(f"Failed login attempt for username: {username}")
    
    # Get demo users for display (without passwords)
    demo_users = User.query.filter(User.username.in_(['admin', 'client1', 'viewer1'])).all()
    demo_accounts = [{'username': user.username, 'role': user.role} for user in demo_users]
    
    return render_template('login.html', demo_accounts=demo_accounts)

@app.route('/demo-login/<username>', methods=['POST'])
def demo_login(username):
    """Demo login endpoint - only works for predefined demo accounts"""
    # Only allow specific demo usernames
    allowed_demo_users = ['admin', 'client1', 'viewer1']
    
    if username not in allowed_demo_users:
        flash('Invalid demo account.', 'error')
        return redirect(url_for('login'))
    
    user = User.query.filter_by(username=username, is_active=True).first()
    
    if user:
        session['user_id'] = user.id
        session['username'] = user.username
        session['role'] = user.role
        
        flash(f'Demo login successful! Welcome, {user.username}!', 'success')
        logger.info(f"Demo login successful for user: {user.username}")
        
        return redirect(url_for('dashboard'))
    else:
        flash('Demo account not found. Please run the demo setup script.', 'error')
        return redirect(url_for('login'))

@app.route('/logout')
def logout():
    """User logout"""
    username = session.get('username', 'Unknown')
    log_activity('user_logout', f'User logged out')
    session.clear()
    flash('You have been logged out successfully.', 'info')
    logger.info(f"User {username} logged out")
    return redirect(url_for('login'))

@app.route('/register', methods=['GET', 'POST'])
def register():
    """User registration"""
    if request.method == 'POST':
        username = request.form.get('username')
        email = request.form.get('email')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')
        
        # Validation
        if not all([username, email, password, confirm_password]):
            flash('All fields are required.', 'error')
            return render_template('register.html')
        
        if password != confirm_password:
            flash('Passwords do not match.', 'error')
            return render_template('register.html')
        
        if len(password) < 6:
            flash('Password must be at least 6 characters long.', 'error')
            return render_template('register.html')
        
        # Check if user already exists
        if User.query.filter_by(username=username).first():
            flash('Username already exists.', 'error')
            return render_template('register.html')
        
        if User.query.filter_by(email=email).first():
            flash('Email already registered.', 'error')
            return render_template('register.html')
        
        # Create new user
        try:
            user = User(
                username=username,
                email=email,
                role='viewer'  # Default role
            )
            user.set_password(password)
            
            db.session.add(user)
            db.session.commit()
            
            flash('Registration successful! You can now log in.', 'success')
            logger.info(f"New user registered: {username}")
            return redirect(url_for('login'))
            
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error during registration: {e}")
            flash('Registration failed. Please try again.', 'error')
    
    return render_template('register.html')

# Dashboard route
@app.route('/dashboard')
@login_required
def dashboard():
    """Main dashboard for logged-in users"""
    user = User.query.get(session['user_id'])
    log_activity('dashboard_accessed')
    
    # Get comprehensive stats based on user role
    if user.role == 'admin':
        stats = {
            'total_locations': Location.query.count(),
            'total_users': User.query.count(),
            'total_campaigns': Campaign.query.count(),
            'total_devices': Device.query.count(),
            'active_campaigns': Campaign.query.filter_by(status='active').count(),
            'online_devices': Device.query.filter_by(status='online').count(),
            'offline_devices': Device.query.filter_by(status='offline').count(),
            'recent_activities': ActivityLog.query.order_by(ActivityLog.created_at.desc()).limit(10).all(),
            'user_role': user.role,
            'username': user.username
        }
    elif user.role == 'client':
        # Client sees only their assigned campaigns and related data
        user_campaigns = Campaign.query.filter_by(client_id=user.id).all()
        stats = {
            'total_campaigns': len(user_campaigns),
            'active_campaigns': len([c for c in user_campaigns if c.status == 'active']),
            'total_budget': sum([c.budget for c in user_campaigns]),
            'total_locations': Location.query.count(),  # Can view all locations
            'total_devices': Device.query.count(),  # Can view all devices
            'online_devices': Device.query.filter_by(status='online').count(),
            'user_campaigns': user_campaigns,
            'user_role': user.role,
            'username': user.username
        }
    else:  # viewer
        stats = {
            'total_locations': Location.query.count(),
            'total_devices': Device.query.count(),
            'online_devices': Device.query.filter_by(status='online').count(),
            'offline_devices': Device.query.filter_by(status='offline').count(),
            'user_role': user.role,
            'username': user.username
        }
    
    return render_template('dashboard.html', stats=stats, user=user)

# Routes
@app.route('/')
def index():
    """Serve the main dashboard page"""
    # Redirect to login if not authenticated
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # If authenticated, redirect to dashboard
    return redirect(url_for('dashboard'))

@app.route('/api')
def api_info():
    """API information endpoint"""
    return jsonify({
        'message': 'Flask Application (Simple Development Version)',
        'status': 'running',
        'version': '1.0.0',
        'database': 'SQLite'
    })

@app.route('/health')
def health_check():
    """Health check endpoint for monitoring"""
    try:
        # Test database connection
        db.session.execute(db.text('SELECT 1'))
        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.utcnow().isoformat(),
            'database': 'connected',
            'type': 'SQLite'
        })
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return jsonify({
            'status': 'unhealthy',
            'timestamp': datetime.utcnow().isoformat(),
            'database': 'disconnected',
            'error': str(e)
        }), 500

@app.route('/api/locations', methods=['GET'])
@login_required
def get_locations():
    """Get all locations (all users can view)"""
    try:
        locations = Location.query.all()
        log_activity('locations_viewed')
        return jsonify([location.to_dict() for location in locations])
    except Exception as e:
        logger.error(f"Error fetching locations: {e}")
        return jsonify({'error': 'Failed to fetch locations'}), 500

@app.route('/api/locations', methods=['POST'])
@login_required
@admin_required
def create_location():
    """Create a new location (admin only)"""
    try:
        data = request.get_json()
        
        if not data or 'name' not in data:
            return jsonify({'error': 'Name is required'}), 400
        
        user = User.query.get(session['user_id'])
        location = Location(
            name=data['name'],
            description=data.get('description'),
            address=data.get('address'),
            status=data.get('status', 'active'),
            created_by=user.id
        )
        
        # Add coordinates if provided
        if 'longitude' in data and 'latitude' in data:
            location.latitude = float(data['latitude'])
            location.longitude = float(data['longitude'])
        
        db.session.add(location)
        db.session.commit()
        
        log_activity('location_created', f'Created location: {location.name}')
        logger.info(f"Created location: {location.name}")
        return jsonify(location.to_dict()), 201
        
    except Exception as e:
        logger.error(f"Error creating location: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to create location'}), 500

@app.route('/api/locations/<int:location_id>', methods=['GET'])
@login_required
def get_location(location_id):
    """Get a specific location (all users can view)"""
    try:
        location = Location.query.get_or_404(location_id)
        log_activity('location_viewed', f'Viewed location: {location.name}')
        return jsonify(location.to_dict())
    except Exception as e:
        logger.error(f"Error fetching location {location_id}: {e}")
        return jsonify({'error': 'Location not found'}), 404

@app.route('/api/locations/<int:location_id>', methods=['PUT'])
@login_required
@admin_required
def update_location(location_id):
    """Update a location (admin only)"""
    try:
        location = Location.query.get_or_404(location_id)
        data = request.get_json()
        
        # Update fields if provided
        if 'name' in data:
            location.name = data['name']
        if 'description' in data:
            location.description = data['description']
        if 'address' in data:
            location.address = data['address']
        if 'status' in data:
            location.status = data['status']
        if 'latitude' in data and 'longitude' in data:
            location.latitude = float(data['latitude']) if data['latitude'] else None
            location.longitude = float(data['longitude']) if data['longitude'] else None
        
        location.updated_at = datetime.utcnow()
        db.session.commit()
        
        log_activity('location_updated', f'Updated location: {location.name}')
        logger.info(f"Updated location: {location.name}")
        return jsonify(location.to_dict())
        
    except Exception as e:
        logger.error(f"Error updating location {location_id}: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to update location'}), 500

@app.route('/api/locations/<int:location_id>', methods=['DELETE'])
@login_required
@admin_required
def delete_location(location_id):
    """Delete a location (admin only)"""
    try:
        location = Location.query.get_or_404(location_id)
        location_name = location.name
        
        db.session.delete(location)
        db.session.commit()
        
        log_activity('location_deleted', f'Deleted location: {location_name}')
        logger.info(f"Deleted location: {location_name}")
        return jsonify({'message': f'Location "{location_name}" deleted successfully'})
        
    except Exception as e:
        logger.error(f"Error deleting location {location_id}: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to delete location'}), 500

# Campaign Management APIs
@app.route('/api/campaigns', methods=['GET'])
@login_required
def get_campaigns():
    """Get campaigns (admin sees all, client sees assigned)"""
    try:
        user = User.query.get(session['user_id'])
        if user.role == 'admin':
            campaigns = Campaign.query.all()
        elif user.role == 'client':
            campaigns = Campaign.query.filter_by(client_id=user.id).all()
        else:
            campaigns = Campaign.query.filter_by(status='active').all()  # viewers see active only
        
        log_activity('campaigns_viewed')
        return jsonify([campaign.to_dict() for campaign in campaigns])
    except Exception as e:
        logger.error(f"Error fetching campaigns: {e}")
        return jsonify({'error': 'Failed to fetch campaigns'}), 500

@app.route('/api/campaigns', methods=['POST'])
@login_required
@admin_required
def create_campaign():
    """Create a new campaign (admin only)"""
    try:
        data = request.get_json()
        user = User.query.get(session['user_id'])
        
        if not data or 'name' not in data:
            return jsonify({'error': 'Campaign name is required'}), 400
        
        campaign = Campaign(
            name=data['name'],
            description=data.get('description'),
            status=data.get('status', 'draft'),
            budget=float(data.get('budget', 0.0)),
            target_audience=data.get('target_audience'),
            created_by=user.id,
            client_id=data.get('client_id')
        )
        
        # Handle dates
        if data.get('start_date'):
            campaign.start_date = datetime.fromisoformat(data['start_date'].replace('Z', '+00:00'))
        if data.get('end_date'):
            campaign.end_date = datetime.fromisoformat(data['end_date'].replace('Z', '+00:00'))
        
        db.session.add(campaign)
        db.session.commit()
        
        log_activity('campaign_created', f"Created campaign: {campaign.name}")
        logger.info(f"Created campaign: {campaign.name}")
        return jsonify(campaign.to_dict()), 201
        
    except Exception as e:
        logger.error(f"Error creating campaign: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to create campaign'}), 500

# Device Management APIs
@app.route('/api/devices', methods=['GET'])
@login_required
def get_devices():
    """Get all devices"""
    try:
        devices = Device.query.all()
        log_activity('devices_viewed')
        return jsonify([device.to_dict() for device in devices])
    except Exception as e:
        logger.error(f"Error fetching devices: {e}")
        return jsonify({'error': 'Failed to fetch devices'}), 500

@app.route('/api/devices', methods=['POST'])
@login_required
@admin_required
def create_device():
    """Create a new device (admin only)"""
    try:
        data = request.get_json()
        
        if not data or 'name' not in data or 'device_type' not in data:
            return jsonify({'error': 'Device name and type are required'}), 400
        
        device = Device(
            name=data['name'],
            device_type=data['device_type'],
            serial_number=data.get('serial_number'),
            status=data.get('status', 'offline'),
            location_id=data.get('location_id'),
            firmware_version=data.get('firmware_version'),
            ip_address=data.get('ip_address')
        )
        
        db.session.add(device)
        db.session.commit()
        
        log_activity('device_created', f"Created device: {device.name}")
        logger.info(f"Created device: {device.name}")
        return jsonify(device.to_dict()), 201
        
    except Exception as e:
        logger.error(f"Error creating device: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to create device'}), 500

@app.route('/api/devices/<int:device_id>/status', methods=['PUT'])
@login_required
@admin_required
def update_device_status(device_id):
    """Update device status (admin only)"""
    try:
        device = Device.query.get_or_404(device_id)
        data = request.get_json()
        
        if 'status' in data:
            old_status = device.status
            device.status = data['status']
            device.last_seen = datetime.utcnow()
            db.session.commit()
            
            log_activity('device_status_updated', f"Device {device.name} status: {old_status} -> {device.status}")
            return jsonify(device.to_dict())
        
        return jsonify({'error': 'Status is required'}), 400
        
    except Exception as e:
        logger.error(f"Error updating device status: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to update device status'}), 500

# User Management APIs (Admin only)
@app.route('/api/users', methods=['GET'])
@login_required
@admin_required
def get_users():
    """Get all users (admin only)"""
    try:
        users = User.query.all()
        log_activity('users_viewed')
        return jsonify([user.to_dict() for user in users])
    except Exception as e:
        logger.error(f"Error fetching users: {e}")
        return jsonify({'error': 'Failed to fetch users'}), 500

@app.route('/api/users/<int:user_id>/role', methods=['PUT'])
@login_required
@admin_required
def update_user_role(user_id):
    """Update user role (admin only)"""
    try:
        user = User.query.get_or_404(user_id)
        data = request.get_json()
        
        if 'role' in data and data['role'] in ['admin', 'client', 'viewer']:
            old_role = user.role
            user.role = data['role']
            db.session.commit()
            
            log_activity('user_role_updated', f"User {user.username} role: {old_role} -> {user.role}")
            return jsonify(user.to_dict())
        
        return jsonify({'error': 'Valid role is required'}), 400
        
    except Exception as e:
        logger.error(f"Error updating user role: {e}")
        db.session.rollback()
        return jsonify({'error': 'Failed to update user role'}), 500

# Activity Log API (Admin only)
@app.route('/api/activity', methods=['GET'])
@login_required
@admin_required
def get_activity_logs():
    """Get activity logs (admin only)"""
    try:
        limit = request.args.get('limit', 50, type=int)
        activities = ActivityLog.query.order_by(ActivityLog.created_at.desc()).limit(limit).all()
        return jsonify([activity.to_dict() for activity in activities])
    except Exception as e:
        logger.error(f"Error fetching activity logs: {e}")
        return jsonify({'error': 'Failed to fetch activity logs'}), 500

# Error handlers
@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    logger.error(f"Internal server error: {error}")
    return jsonify({'error': 'Internal server error'}), 500

# Initialize database
def create_tables():
    """Create database tables"""
    try:
        with app.app_context():
            db.create_all()
            logger.info("Database tables created successfully")
    except Exception as e:
        logger.error(f"Error creating database tables: {e}")


if __name__ == '__main__':
    # Create tables when running directly
    create_tables()
    
    app.run(host='0.0.0.0', port=5000, debug=True)
